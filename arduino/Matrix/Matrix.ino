#include <LedControl.h>
#include <DHT.h>

/* #define __DUE__ */
#ifdef __DUE__
#include <DueTimer.h>
#endif

// Number of LED matrices
#define DEVICES 1

// LED matrix cell size
#define SIZE 8

#define LED_DATA 8
#define LED_CLK 9
#define LED_CS 10

LedControl lc = LedControl(LED_DATA, LED_CLK, LED_CS, DEVICES);

#define TEMP_DATA 6

DHT dht(TEMP_DATA, DHT11);

#define PIR_DATA 2
#define PIR_SHOW_LED 13

unsigned long delaytime = 100;

#define ADD_NOISE 0

#define BOUNDS 0

void setup()
{

  Serial.begin(115200);

  pinMode(PIR_DATA, INPUT);
  pinMode(PIR_SHOW_LED, OUTPUT);

  analogWriteResolution(12);
  //  analogReadResolution(12);

  for (int d = 0; d < DEVICES; d++)
  {
    // Wake up
    lc.shutdown(d, false);

    // Med brighness
    lc.setIntensity(d, 12);

    // Fade brigthness
    // lc.setIntensity(d,1+d*d);

    // Clear
    lc.clearDisplay(d);
  }
}

byte font[128][8] =
{
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 0000
  {0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 0001
  {0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 0002
  {0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00}, // 0003
  {0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00}, // 0004
  {0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00}, // 0005
  {0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00}, // 0006
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00}, // 0007
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff}, // 0008
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x00}, // 0009
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x00, 0x00}, // 000a
  {0x00, 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00}, // 000b
  {0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 0x00}, // 000c
  {0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00}, // 000d
  {0x00, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 000e
  {0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 000f
  {0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00}, // 0010
  {0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00}, // 0011
  {0x00, 0x18, 0x3c, 0x7e, 0x7e, 0x3c, 0x18, 0x00}, // 0012
  {0x18, 0x3c, 0x7e, 0xff, 0xff, 0x7e, 0x3c, 0x18}, // 0013
  {0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18}, // 0014
  {0x00, 0x18, 0x24, 0x42, 0x42, 0x24, 0x18, 0x00}, // 0015
  {0x00, 0x00, 0x18, 0x24, 0x24, 0x18, 0x00, 0x00}, // 0016
  {0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00}, // 0017
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 0018
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 0019
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 001a
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 001b
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 001c
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 001d
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 001e
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 001f
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 0020 ' '
  {0x18, 0x3c, 0x3c, 0x18, 0x18, 0x00, 0x18, 0x00}, // 0021 '!'
  {0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 0022 '"'
  {0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00}, // 0023 '#'
  {0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00}, // 0024 '$'
  {0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00}, // 0025 '%'
  {0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00}, // 0026 '&'
  {0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00}, // 0027 '''
  {0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00}, // 0028 '('
  {0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00}, // 0029 ')'
  {0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00}, // 002a '*'
  {0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00}, // 002b '+'
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60}, // 002c ','
  {0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00}, // 002d '-'
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00}, // 002e '.'
  {0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00}, // 002f '/'
  {0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00}, // 0030 '0'
  {0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00}, // 0031 '1'
  {0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00}, // 0032 '2'
  {0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00}, // 0033 '3'
  {0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00}, // 0034 '4'
  {0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00}, // 0035 '5'
  {0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00}, // 0036 '6'
  {0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00}, // 0037 '7'
  {0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00}, // 0038 '8'
  {0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00}, // 0039 '9'
  {0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00}, // 003a ':'
  {0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60}, // 003b ';'
  {0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00}, // 003c '<'
  {0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00}, // 003d '='
  {0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00}, // 003e '>'
  {0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00}, // 003f '?'
  {0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00}, // 0040 '@'
  {0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00}, // 0041 'A'
  {0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00}, // 0042 'B'
  {0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00}, // 0043 'C'
  {0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00}, // 0044 'D'
  {0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00}, // 0045 'E'
  {0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00}, // 0046 'F'
  {0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00}, // 0047 'G'
  {0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00}, // 0048 'H'
  {0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00}, // 0049 'I'
  {0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00}, // 004a 'J'
  {0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00}, // 004b 'K'
  {0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00}, // 004c 'L'
  {0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00}, // 004d 'M'
  {0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00}, // 004e 'N'
  {0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00}, // 004f 'O'
  {0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00}, // 0050 'P'
  {0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00}, // 0051 'Q'
  {0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00}, // 0052 'R'
  {0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00}, // 0053 'S'
  {0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00}, // 0054 'T'
  {0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00}, // 0055 'U'
  {0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00}, // 0056 'V'
  {0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00}, // 0057 'W'
  {0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00}, // 0058 'X'
  {0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00}, // 0059 'Y'
  {0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00}, // 005a 'Z'
  {0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00}, // 005b '['
  {0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00}, // 005c '\'
  {0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00}, // 005d ']'
  {0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00}, // 005e '^'
  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff}, // 005f '_'
  {0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00}, // 0060 '`'
  {0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00}, // 0061 'a'
  {0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00}, // 0062 'b'
  {0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00}, // 0063 'c'
  {0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00}, // 0064 'd'
  {0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00}, // 0065 'e'
  {0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00}, // 0066 'f'
  {0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8}, // 0067 'g'
  {0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00}, // 0068 'h'
  {0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00}, // 0069 'i'
  {0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78}, // 006a 'j'
  {0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00}, // 006b 'k'
  {0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00}, // 006c 'l'
  {0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00}, // 006d 'm'
  {0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00}, // 006e 'n'
  {0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00}, // 006f 'o'
  {0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0}, // 0070 'p'
  {0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e}, // 0071 'q'
  {0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00}, // 0072 'r'
  {0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00}, // 0073 's'
  {0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00}, // 0074 't'
  {0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00}, // 0075 'u'
  {0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00}, // 0076 'v'
  {0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00}, // 0077 'w'
  {0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00}, // 0078 'x'
  {0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8}, // 0079 'y'
  {0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00}, // 007a 'z'
  {0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00}, // 007b '{'
  {0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00}, // 007c '|'
  {0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00}, // 007d '}'
  {0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 007e '~'
  {0x60, 0x90, 0x90, 0x66, 0x09, 0x08, 0x09, 0x06}  // 007f
};

struct pos
{
  int x;
  int y;
};

struct pos spiral(int size, struct pos in)
{
  struct pos out = {size / 2, size / 2 - 1};
  struct pos iter = {0, 0};

  int inc_y = 1;
  int inc = 1;
  int inc_l = 1;
  int inc_curl = 1;

  while (iter.x != in.x || iter.y != in.y)
  {
    if (inc_y)
    {
      out.y += inc;
      inc_curl--;

      if (inc_curl == 0)
      {
        inc_y = 0;
        inc_curl = inc_l;
        inc = -inc;
      }
    }
    else
    {
      out.x += inc;
      inc_curl--;

      if (inc_curl == 0)
      {
        inc_y = 1;
        inc_l++;
        inc_curl = inc_l;
      }
    }

    iter.x++;
    if (iter.x == size)
    {
      iter.x = 0;
      iter.y++;
    }
  }

  return out;
}

void testSpiral()
{
  int y, x;
  int size = 4;

  for (int y = 0; y < size; y++)
    for (int x = 0; x < size; x++)
    {

      struct pos in = {x, y};
      struct pos out = spiral(size, in);

      Serial.print("in: ");
      Serial.print(in.x);
      Serial.print(", ");
      Serial.print(in.y);
      Serial.print(" => ");
      Serial.print(out.x);
      Serial.print(", ");
      Serial.println(out.y);
    }
}

void showCharN(int size, int n, byte *ch)
{
  int x, y;

  for (y = 0; y < size; y++)
  {
    for (x = 0; x < size; x++)
    {
      byte mask = 1 << (size - 1 - x);

      lc.setLed(n, y, x, ch[y] & mask);
    }
  }
}

void showChar(int size, byte *ch)
{
  showCharN(size, 0, ch);
}

void fastShowCharN(int size, int n, byte *ch)
{
  int r;

  for (r = 0; r < size; r++)
  {
    byte noise = 0;

    if (ADD_NOISE)
    {
      noise = (random(ADD_NOISE) & random(ADD_NOISE) & random(ADD_NOISE) & random(ADD_NOISE)) & 0xFF;
    }

    byte c = ch[r] ^ noise;

    if (BOUNDS)
    {
      if (r == 0 || r == 7)
        c = c | 0x81;
    }

    lc.setRow(n, r, c);
  }
}

void fastShowChar(int size, byte *ch)
{
  fastShowCharN(size, 0, ch);
}

void setBit(int n, int y, int x, int b)
{
  lc.setLed(n, y, x, 1);
  delay(delaytime / 50);
  lc.setLed(n, y, x, b);
}

void showCharSpiralN(int size, int n, byte *ch)
{
  for (int y = 0; y < size; y++)
  {

    for (int x = 0; x < size; x++)
    {

      struct pos in = {x, y};

      struct pos out = spiral(size, in);

      byte mask = 1 << (size - 1 - out.x);

      setBit(n, out.y, out.x, ch[out.y] & mask);
    }
  }
}

void showCharSpiral(int size, byte *ch)
{
  showCharSpiralN(size, 0, ch);
}

void showCharWipeN(int size, int n, int y, int x, unsigned char *ch, int vert, int dir)
{
  for (int i = 0; i < size; i++)
  {
    for (int j = 0; j < size; j++)
    {

      unsigned char mask;
      unsigned char bit;

      if (vert)
      {
        if (dir)
        {
          mask = 1 << (size - 1 - i);
          bit = ch[j] & mask;
          setBit(n, j, i, bit);
        }
        else
        {
          mask = 1 << (i);
          bit = ch[j] & mask;
          setBit(n, j, size - 1 - i, bit);
        }
      }
      else
      {
        if (dir)
        {
          mask = 1 << (size - 1 - j);
          bit = ch[i] & mask;
          setBit(n, i, j, bit);
        }
        else
        {
          mask = 1 << (j);
          bit = ch[size - 1 - i] & mask;
          setBit(n, size - 1 - i, size - 1 - j, bit);
        }
      }
    }
  }
}

void showCharWipe(int size, int n, int y, int x, unsigned char *ch, int vert, int dir)
{
  showCharWipeN(size, 0, y, x, ch, vert, dir);
}

void writeArduinoOnMatrix()
{
  int i, j, b;

  // lc.setIntensity(0,12);

  for (i = 32; i < 128; i++)
  {
    for (int n = 0; n < DEVICES; n++)
    {
      showCharSpiralN(SIZE, n, font[i]);
    }
    delay(delaytime * 10);

    for (int n = 0; n < DEVICES; n++)
    {
      showCharN(SIZE, n, font[0]);
    }
    delay(delaytime);

    for (int n = 0; n < DEVICES; n++)
    {
      showCharWipeN(SIZE, n, 1, 7, font[i], i % 4 / 2, (i % 4) % 2);
    }
    delay(delaytime * 10);
  }
}

#ifdef __DUE__
long fire = 0;

void fireNow()
{
  fire = 1;
}

int setupTimer(long t)
{
  Timer3.attachInterrupt(fireNow).start(t);

  return 1;
}
#else
long fire = 1;

int setupTimer(long t)
{
  return 0;
}
#endif

void bigCounter()
{

  unsigned char big[SIZE];

  int i;

  for (i = 0; i < SIZE; i++)
  {
    big[i] = 0;
  }

  int haveTimer = setupTimer(1000000 / 25);

  // lc.setIntensity(0,15);

  long n = 0;

  while (1)
  {
    int i = 0;
    while (i < SIZE && (++big[i++] == 0))
      ;

    n++;

    if (fire)
    {
      for (int n = 0; n < DEVICES; n++)
      {
        fastShowCharN(SIZE, n, big);
      }

      if (haveTimer)
        fire = 0;
    }

    if (!haveTimer)
      delay(delaytime);
  }
}

void showScroll(int size, int pos, int n, byte *ch1, byte *ch2)
{
  byte newChar[size];

  for (int i = 0; i < size; i++)
  {
    newChar[i] = ((ch1[i] << pos) | (ch2[i] >> (size - pos)));
  }

  fastShowCharN(SIZE, n, newChar);
}

void showScrollAnimation(int size, int frames, int pos, byte *ch1[], byte *ch2[])
{
  byte newChar[size];

  int frame = pos % frames;

  for (int i = 0; i < size; i++)
  {
    newChar[i] = ((ch1[frame][i] << pos) | (ch2[frame][i] >> (size - pos)));
  }

  fastShowChar(SIZE, newChar);
}

void scrollAnimation()
{
  byte *ch1[] = {font[0x10], font[0x11], font[0x12], font[0x13], font[0x14], font[0x15], font[0x16]};
  byte *ch2[] = {font[0x10], font[0x11], font[0x12], font[0x13], font[0x14], font[0x15], font[0x16]};

  for (int p = 0; p < SIZE; p++)
  {
    showScrollAnimation(SIZE, 7, p, ch1, ch2);

    // showScroll( SIZE, p, 0, ch1[0], ch2[0] );

    delay(60);
  }
}

void scrollString(int size, int width, const char *string)
{
  int len = strlen(string);
  int pos = 0;
  int lastPos = len - width;

  if (lastPos < 0)
  {
    lastPos = pos;
  }

  if (len > width)
  {
    int i = 0;
    do
    {
      for (int p = 0; p < size; p++)
      {
        for (int j = 0; j < width; j++)
        {
          showScroll(size, p, width - j - 1, font[string[i + j]], font[string[i + j + 1]]);
        }
        delay(delaytime);
      }

      i++;
    } while (i < lastPos);
  }

  // Final position
  for (int j = 0; j < width; j++)
  {
    showScroll(size, 0, width - j - 1, font[string[len - (width - j)]], font[string[len - (width - j)]]);
  }
  delay(delaytime);
}

void animateString(const char *string, int delayTime)
{
  int len = strlen(string);

  for (int i = 0; i < len; i++)
  {
    for (int n = 0; n < DEVICES; n++)
    {
      fastShowCharN(SIZE, n, font[string[i]]);
    }
    delay(delayTime);
  }
}

int limit(int v, int min, int max)
{
  if (v < min)
    return min;
  if (v > max)
    return max;
  return v;
}

void setDisplay(int intensity)
{
  for (int d = 0; d <= DEVICES; d++)
  {
    lc.setIntensity(d, intensity);
  }
}

void fadeDisplay(int times, int start, int fin, int del)
{
  int s = limit(start, 0, 15);
  int e = limit(fin, 0, 15);

  if (times % 2 == 1)
    times++;

  for (int t = 0; t < times; t++)
  {
    int inc = 1;

    if (s > e)
      inc = -1;

    for (int b = s; b != e; b = b + inc)
    {
      for (int d = 0; d <= DEVICES; d++)
      {
        lc.setIntensity(d, b);
      }
      delay(del);
    }

    int tmp = s;
    s = e;
    e = tmp;
  }
}

void nowServing()
{
  int now = 100;

  int intensity = 12;

  do
  {
    char msg[60];

    sprintf(msg, "    ... Now serving>%3d", now);

    setDisplay(intensity);

    scrollString(SIZE, DEVICES, msg);

    int del = random(3) * 3 + 1;

    int inc = 1;

    if (random(10) <= 3)
    {
      inc += (random(3) + 1);
    }

    fadeDisplay(del * inc, intensity, 1, 80);

    now += inc;

    if (now > 999)
    {
      now = 42;
    }

  } while (true);
}

void phpIs()
{
  const char *whats[] =
  {
    "Shit",
    "ACE!",
    "Okay",
    "Duff"
  };

  int delayTime = 2000;

  int numWhats = sizeof(whats) / sizeof(*whats);

  char msg[64];

  sprintf(msg, "PHP is ...");
  scrollString(SIZE, DEVICES, msg);
  delay(delayTime);

  int what = random(numWhats);
  scrollString(SIZE, DEVICES, whats[what]);
  delay(delayTime);
}

void tempAndHumidity()
{
  const int oneSec = 1000;
  const int preReadDelay = 2 * oneSec;

  delay(preReadDelay);

  dht.read();

  float temp = dht.readTemperature();
  float humidity = dht.readHumidity();

  char msg[64];

  if (isnan(temp) || isnan(humidity))
  {
    sprintf(msg, "Bad read!");
    scrollString(SIZE, DEVICES, msg);
  }
  else
  {
    sprintf(msg, "t=%2.0f\x7f", temp);
    scrollString(SIZE, DEVICES, msg);
    delay(oneSec);
    sprintf(msg, "h=%2.0f%%", humidity);
    scrollString(SIZE, DEVICES, msg);
  }
  delay(oneSec);
}

void animationTest()
{
  for (int i = 1; i < 20; i++)
  {
    char buf[20];

    sprintf(buf, " d=%dms ", i);
    scrollString(SIZE, DEVICES, buf);

    const char *msg = "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0d\x0e\x0f";
    int len = strlen(msg);
    const char *msg2 = "\x10\x11\x12\x13\x14\x15\x16\x17";

    int d = i * 10;
    int j = 1000 / (d * len);

    do
    {
      animateString(msg, d);

      animateString(msg2, d);

      j--;
    } while (j >= 0);
  }
}

void scrollAnimationLoop(int n)
{
  for (int l = 0; l <= n; l++)
  {
    scrollAnimation();
  }
}

#define SET_CELL(b, x, y) b[y] = b[y] | (1 << (SIZE - x - 1))
#define CLR_CELL(b, x, y) b[y] = b[y] & (~(1 << (SIZE - x - 1)) & 0xFF)
#define CELL_ISSET(b, x, y) ((b[y] & (1 << (SIZE - x - 1))) != 0)

int lifeBoardEmpty(byte b[8])
{
  for (int i = 0; i < SIZE; i++)
  {
    if (b[i])
      return 0;
  }

  return 1;
}

int lifeBoardCopy(byte from[8], byte to[8])
{
  for (int i = 0; i < SIZE; i++)
  {
    to[i] = from[i];
  }
}

int lifeBoardsSame(byte b1[8], byte b2[8])
{

  for (int i = 0; i < SIZE; i++)
  {
    if (b1[i] != b2[i])
      return 0;
  }

  return 1;
}

int lifeNeighbours(byte b[8], int x, int y)
{
  int res = 0;

  for (int r = y - 1; r < y + 2; r++)
  {
    for (int c = x - 1; c < x + 2; c++)
    {
      if ((r >= 0 && r < SIZE) && (c >= 0 && c < SIZE))
      {
        if (CELL_ISSET(b, c, r))
        {
          res++;
        }
      }
    }
  }

  if (CELL_ISSET(b, x, y))
  {
    res--;
  }

  return res;
}

void gameOfLife()
{
  byte b[8] = {0, 0, 0x70, 0, 0, 0x07, 0, 0};
  byte oldB[8];

  for (int i = 0; i < SIZE; i++)
  {
    // SET_CELL( b, i, i );

    b[i] = random(256);
  }

  fastShowChar(SIZE, b);

  delay(1000);

  int iterations = 100;
  int done = 0;

  while (!done && !lifeBoardEmpty(b) && iterations)
  {
    lifeBoardCopy(b, oldB);

    for (int y = 0; y < SIZE; y++)
    {
      for (int x = 0; x < SIZE; x++)
      {
        int nbs = lifeNeighbours(oldB, x, y);
        int live = CELL_ISSET(oldB, x, y);

        if (live)
        {
          if ((nbs < 2) || (nbs > 3))
          {
            CLR_CELL(b, x, y);
          }
        }
        else
        {
          if (nbs == 3)
          {
            SET_CELL(b, x, y);
          }
        }
      }
    }

    fastShowChar(SIZE, b);

    delay(60);

    done = lifeBoardsSame(b, oldB);

    iterations--;
  }

  delay(1000);

  int setCount = 0;

  for (int y = 0; y < SIZE; y++)
  {
    for (int x = 0; x < SIZE; x++)
    {
      if (CELL_ISSET(b, x, y))
      {
        setCount++;
      }
    }
  }

  char msg[65];
  sprintf(msg, "#=%d i=%d", setCount, 100 - iterations);
  scrollString(SIZE, DEVICES, msg);

  delay(1000);
}

void checkPir()
{
  int delayTime = 20;
  int pirRead;

  pirRead = digitalRead(PIR_DATA);

  if (pirRead == HIGH)
  {
    digitalWrite(PIR_SHOW_LED, HIGH);
  }
  else
  {
    digitalWrite(PIR_SHOW_LED, LOW);
  }

  if (pirRead == HIGH)
  {
    scrollString(SIZE, DEVICES, "...!!! STOP !!!...");
  }
  else
  {
    animateString("|/-\\", 200);
  }

  delay(delayTime);
}

int waveData[] = {
  0x800, 0x80c, 0x819, 0x825, 0x832, 0x83e, 0x84b, 0x858,
  0x864, 0x871, 0x87d, 0x88a, 0x896, 0x8a3, 0x8af, 0x8bc,
  0x8c8, 0x8d5, 0x8e1, 0x8ee, 0x8fa, 0x907, 0x913, 0x920,
  0x92c, 0x939, 0x945, 0x951, 0x95e, 0x96a, 0x977, 0x983,
  0x98f, 0x99c, 0x9a8, 0x9b4, 0x9c1, 0x9cd, 0x9d9, 0x9e5,
  0x9f1, 0x9fe, 0xa0a, 0xa16, 0xa22, 0xa2e, 0xa3a, 0xa46,
  0xa52, 0xa5e, 0xa6a, 0xa76, 0xa82, 0xa8e, 0xa9a, 0xaa6,
  0xab2, 0xabe, 0xaca, 0xad5, 0xae1, 0xaed, 0xaf8, 0xb04,
  0xb10, 0xb1b, 0xb27, 0xb32, 0xb3e, 0xb49, 0xb55, 0xb60,
  0xb6c, 0xb77, 0xb82, 0xb8e, 0xb99, 0xba4, 0xbaf, 0xbba,
  0xbc6, 0xbd1, 0xbdc, 0xbe7, 0xbf2, 0xbfd, 0xc07, 0xc12,
  0xc1d, 0xc28, 0xc33, 0xc3d, 0xc48, 0xc52, 0xc5d, 0xc68,
  0xc72, 0xc7c, 0xc87, 0xc91, 0xc9b, 0xca6, 0xcb0, 0xcba,
  0xcc4, 0xcce, 0xcd8, 0xce2, 0xcec, 0xcf6, 0xd00, 0xd0a,
  0xd13, 0xd1d, 0xd27, 0xd30, 0xd3a, 0xd43, 0xd4d, 0xd56,
  0xd60, 0xd69, 0xd72, 0xd7b, 0xd84, 0xd8e, 0xd97, 0xd9f,
  0xda8, 0xdb1, 0xdba, 0xdc3, 0xdcc, 0xdd4, 0xddd, 0xde5,
  0xdee, 0xdf6, 0xdfe, 0xe07, 0xe0f, 0xe17, 0xe1f, 0xe27,
  0xe2f, 0xe37, 0xe3f, 0xe47, 0xe4f, 0xe56, 0xe5e, 0xe66,
  0xe6d, 0xe75, 0xe7c, 0xe83, 0xe8b, 0xe92, 0xe99, 0xea0,
  0xea7, 0xeae, 0xeb5, 0xebc, 0xec2, 0xec9, 0xed0, 0xed6,
  0xedd, 0xee3, 0xeea, 0xef0, 0xef6, 0xefc, 0xf02, 0xf08,
  0xf0e, 0xf14, 0xf1a, 0xf20, 0xf25, 0xf2b, 0xf31, 0xf36,
  0xf3b, 0xf41, 0xf46, 0xf4b, 0xf50, 0xf55, 0xf5a, 0xf5f,
  0xf64, 0xf69, 0xf6d, 0xf72, 0xf77, 0xf7b, 0xf80, 0xf84,
  0xf88, 0xf8c, 0xf90, 0xf94, 0xf98, 0xf9c, 0xfa0, 0xfa4,
  0xfa8, 0xfab, 0xfaf, 0xfb2, 0xfb6, 0xfb9, 0xfbc, 0xfbf,
  0xfc2, 0xfc5, 0xfc8, 0xfcb, 0xfce, 0xfd1, 0xfd3, 0xfd6,
  0xfd8, 0xfdb, 0xfdd, 0xfdf, 0xfe1, 0xfe3, 0xfe5, 0xfe7,
  0xfe9, 0xfeb, 0xfed, 0xfee, 0xff0, 0xff1, 0xff3, 0xff4,
  0xff5, 0xff7, 0xff8, 0xff9, 0xffa, 0xffb, 0xffb, 0xffc,
  0xffd, 0xffd, 0xffe, 0xffe, 0xffe, 0xfff, 0xfff, 0xfff,
  0xfff, 0xfff, 0xfff, 0xfff, 0xffe, 0xffe, 0xffd, 0xffd,
  0xffc, 0xffc, 0xffb, 0xffa, 0xff9, 0xff8, 0xff7, 0xff6,
  0xff5, 0xff4, 0xff2, 0xff1, 0xfef, 0xfee, 0xfec, 0xfea,
  0xfe8, 0xfe6, 0xfe4, 0xfe2, 0xfe0, 0xfde, 0xfdc, 0xfd9,
  0xfd7, 0xfd4, 0xfd2, 0xfcf, 0xfcc, 0xfca, 0xfc7, 0xfc4,
  0xfc1, 0xfbe, 0xfba, 0xfb7, 0xfb4, 0xfb0, 0xfad, 0xfa9,
  0xfa6, 0xfa2, 0xf9e, 0xf9a, 0xf96, 0xf92, 0xf8e, 0xf8a,
  0xf86, 0xf82, 0xf7d, 0xf79, 0xf74, 0xf70, 0xf6b, 0xf66,
  0xf62, 0xf5d, 0xf58, 0xf53, 0xf4e, 0xf49, 0xf43, 0xf3e,
  0xf39, 0xf33, 0xf2e, 0xf28, 0xf23, 0xf1d, 0xf17, 0xf11,
  0xf0b, 0xf05, 0xeff, 0xef9, 0xef3, 0xeed, 0xee6, 0xee0,
  0xeda, 0xed3, 0xecc, 0xec6, 0xebf, 0xeb8, 0xeb1, 0xeab,
  0xea4, 0xe9c, 0xe95, 0xe8e, 0xe87, 0xe80, 0xe78, 0xe71,
  0xe69, 0xe62, 0xe5a, 0xe53, 0xe4b, 0xe43, 0xe3b, 0xe33,
  0xe2b, 0xe23, 0xe1b, 0xe13, 0xe0b, 0xe03, 0xdfa, 0xdf2,
  0xde9, 0xde1, 0xdd8, 0xdd0, 0xdc7, 0xdbe, 0xdb6, 0xdad,
  0xda4, 0xd9b, 0xd92, 0xd89, 0xd80, 0xd77, 0xd6e, 0xd64,
  0xd5b, 0xd52, 0xd48, 0xd3f, 0xd35, 0xd2c, 0xd22, 0xd18,
  0xd0f, 0xd05, 0xcfb, 0xcf1, 0xce7, 0xcdd, 0xcd3, 0xcc9,
  0xcbf, 0xcb5, 0xcab, 0xca1, 0xc96, 0xc8c, 0xc82, 0xc77,
  0xc6d, 0xc62, 0xc58, 0xc4d, 0xc43, 0xc38, 0xc2d, 0xc22,
  0xc18, 0xc0d, 0xc02, 0xbf7, 0xbec, 0xbe1, 0xbd6, 0xbcb,
  0xbc0, 0xbb5, 0xbaa, 0xb9f, 0xb93, 0xb88, 0xb7d, 0xb71,
  0xb66, 0xb5b, 0xb4f, 0xb44, 0xb38, 0xb2d, 0xb21, 0xb16,
  0xb0a, 0xafe, 0xaf3, 0xae7, 0xadb, 0xacf, 0xac4, 0xab8,
  0xaac, 0xaa0, 0xa94, 0xa88, 0xa7c, 0xa70, 0xa64, 0xa58,
  0xa4c, 0xa40, 0xa34, 0xa28, 0xa1c, 0xa10, 0xa04, 0x9f8,
  0x9eb, 0x9df, 0x9d3, 0x9c7, 0x9ba, 0x9ae, 0x9a2, 0x995,
  0x989, 0x97d, 0x970, 0x964, 0x958, 0x94b, 0x93f, 0x932,
  0x926, 0x91a, 0x90d, 0x901, 0x8f4, 0x8e8, 0x8db, 0x8cf,
  0x8c2, 0x8b6, 0x8a9, 0x89d, 0x890, 0x883, 0x877, 0x86a,
  0x85e, 0x851, 0x845, 0x838, 0x82c, 0x81f, 0x812, 0x806,
  0x7f9, 0x7ed, 0x7e0, 0x7d3, 0x7c7, 0x7ba, 0x7ae, 0x7a1,
  0x795, 0x788, 0x77c, 0x76f, 0x762, 0x756, 0x749, 0x73d,
  0x730, 0x724, 0x717, 0x70b, 0x6fe, 0x6f2, 0x6e5, 0x6d9,
  0x6cd, 0x6c0, 0x6b4, 0x6a7, 0x69b, 0x68f, 0x682, 0x676,
  0x66a, 0x65d, 0x651, 0x645, 0x638, 0x62c, 0x620, 0x614,
  0x607, 0x5fb, 0x5ef, 0x5e3, 0x5d7, 0x5cb, 0x5bf, 0x5b3,
  0x5a7, 0x59b, 0x58f, 0x583, 0x577, 0x56b, 0x55f, 0x553,
  0x547, 0x53b, 0x530, 0x524, 0x518, 0x50c, 0x501, 0x4f5,
  0x4e9, 0x4de, 0x4d2, 0x4c7, 0x4bb, 0x4b0, 0x4a4, 0x499,
  0x48e, 0x482, 0x477, 0x46c, 0x460, 0x455, 0x44a, 0x43f,
  0x434, 0x429, 0x41e, 0x413, 0x408, 0x3fd, 0x3f2, 0x3e7,
  0x3dd, 0x3d2, 0x3c7, 0x3bc, 0x3b2, 0x3a7, 0x39d, 0x392,
  0x388, 0x37d, 0x373, 0x369, 0x35e, 0x354, 0x34a, 0x340,
  0x336, 0x32c, 0x322, 0x318, 0x30e, 0x304, 0x2fa, 0x2f0,
  0x2e7, 0x2dd, 0x2d3, 0x2ca, 0x2c0, 0x2b7, 0x2ad, 0x2a4,
  0x29b, 0x291, 0x288, 0x27f, 0x276, 0x26d, 0x264, 0x25b,
  0x252, 0x249, 0x241, 0x238, 0x22f, 0x227, 0x21e, 0x216,
  0x20d, 0x205, 0x1fc, 0x1f4, 0x1ec, 0x1e4, 0x1dc, 0x1d4,
  0x1cc, 0x1c4, 0x1bc, 0x1b4, 0x1ac, 0x1a5, 0x19d, 0x196,
  0x18e, 0x187, 0x17f, 0x178, 0x171, 0x16a, 0x163, 0x15b,
  0x154, 0x14e, 0x147, 0x140, 0x139, 0x133, 0x12c, 0x125,
  0x11f, 0x119, 0x112, 0x10c, 0x106, 0x100, 0xfa, 0xf4,
  0xee, 0xe8, 0xe2, 0xdc, 0xd7, 0xd1, 0xcc, 0xc6,
  0xc1, 0xbc, 0xb6, 0xb1, 0xac, 0xa7, 0xa2, 0x9d,
  0x99, 0x94, 0x8f, 0x8b, 0x86, 0x82, 0x7d, 0x79,
  0x75, 0x71, 0x6d, 0x69, 0x65, 0x61, 0x5d, 0x59,
  0x56, 0x52, 0x4f, 0x4b, 0x48, 0x45, 0x41, 0x3e,
  0x3b, 0x38, 0x35, 0x33, 0x30, 0x2d, 0x2b, 0x28,
  0x26, 0x23, 0x21, 0x1f, 0x1d, 0x1b, 0x19, 0x17,
  0x15, 0x13, 0x11, 0x10, 0xe, 0xd, 0xb, 0xa,
  0x9, 0x8, 0x7, 0x6, 0x5, 0x4, 0x3, 0x3,
  0x2, 0x2, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x2, 0x2,
  0x3, 0x4, 0x4, 0x5, 0x6, 0x7, 0x8, 0xa,
  0xb, 0xc, 0xe, 0xf, 0x11, 0x12, 0x14, 0x16,
  0x18, 0x1a, 0x1c, 0x1e, 0x20, 0x22, 0x24, 0x27,
  0x29, 0x2c, 0x2e, 0x31, 0x34, 0x37, 0x3a, 0x3d,
  0x40, 0x43, 0x46, 0x49, 0x4d, 0x50, 0x54, 0x57,
  0x5b, 0x5f, 0x63, 0x67, 0x6b, 0x6f, 0x73, 0x77,
  0x7b, 0x7f, 0x84, 0x88, 0x8d, 0x92, 0x96, 0x9b,
  0xa0, 0xa5, 0xaa, 0xaf, 0xb4, 0xb9, 0xbe, 0xc4,
  0xc9, 0xce, 0xd4, 0xda, 0xdf, 0xe5, 0xeb, 0xf1,
  0xf7, 0xfd, 0x103, 0x109, 0x10f, 0x115, 0x11c, 0x122,
  0x129, 0x12f, 0x136, 0x13d, 0x143, 0x14a, 0x151, 0x158,
  0x15f, 0x166, 0x16d, 0x174, 0x17c, 0x183, 0x18a, 0x192,
  0x199, 0x1a1, 0x1a9, 0x1b0, 0x1b8, 0x1c0, 0x1c8, 0x1d0,
  0x1d8, 0x1e0, 0x1e8, 0x1f0, 0x1f8, 0x201, 0x209, 0x211,
  0x21a, 0x222, 0x22b, 0x233, 0x23c, 0x245, 0x24e, 0x257,
  0x260, 0x268, 0x271, 0x27b, 0x284, 0x28d, 0x296, 0x29f,
  0x2a9, 0x2b2, 0x2bc, 0x2c5, 0x2cf, 0x2d8, 0x2e2, 0x2ec,
  0x2f5, 0x2ff, 0x309, 0x313, 0x31d, 0x327, 0x331, 0x33b,
  0x345, 0x34f, 0x359, 0x364, 0x36e, 0x378, 0x383, 0x38d,
  0x397, 0x3a2, 0x3ad, 0x3b7, 0x3c2, 0x3cc, 0x3d7, 0x3e2,
  0x3ed, 0x3f8, 0x402, 0x40d, 0x418, 0x423, 0x42e, 0x439,
  0x445, 0x450, 0x45b, 0x466, 0x471, 0x47d, 0x488, 0x493,
  0x49f, 0x4aa, 0x4b6, 0x4c1, 0x4cd, 0x4d8, 0x4e4, 0x4ef,
  0x4fb, 0x507, 0x512, 0x51e, 0x52a, 0x535, 0x541, 0x54d,
  0x559, 0x565, 0x571, 0x57d, 0x589, 0x595, 0x5a1, 0x5ad,
  0x5b9, 0x5c5, 0x5d1, 0x5dd, 0x5e9, 0x5f5, 0x601, 0x60e,
  0x61a, 0x626, 0x632, 0x63e, 0x64b, 0x657, 0x663, 0x670,
  0x67c, 0x688, 0x695, 0x6a1, 0x6ae, 0x6ba, 0x6c6, 0x6d3,
  0x6df, 0x6ec, 0x6f8, 0x705, 0x711, 0x71e, 0x72a, 0x737,
  0x743, 0x750, 0x75c, 0x769, 0x775, 0x782, 0x78e, 0x79b,
  0x7a7, 0x7b4, 0x7c1, 0x7cd, 0x7da, 0x7e6, 0x7f3, 0x800
};

// TODO: Separate out sine (table based) and others which can be specified via parameters
// TODO: Others being square, ramp, steps and triangle - parameters being frequency, duty cycle etc
// TODO: Also inverted option, modulation - see square wave

// Looks like DUE is limited to 133kHZ for a simple square wave at 50% duty cycle

void sineWave(int freq, int seconds)
{
  const int NUM_SAMPLES = sizeof(waveData) / sizeof(int);

  char msg[240];

  int uSecDelay = 1000000 / (NUM_SAMPLES * freq);

  // 10s of signal generation
  const int CYCLES = seconds * freq;

  sprintf(msg, "f=%d, d=%d us, #c=%d", freq, uSecDelay, CYCLES);
  Serial.println(msg);

  for (int c = 0; c < CYCLES; c++)
  {
    analogWrite(DAC1, c % 2 == 0 ? 0xfff : 0 );

    for (int i = 0; i < NUM_SAMPLES; i++)
    {
      // Sawtooth - with sub-sampling
      //      int numRamps = 16;  // Or frequency, but with 'sub-sampling'
      //
      //      analogWrite(DAC0, (( i * numRamps ) % NUM_SAMPLES) * 0xfff / NUM_SAMPLES );  // Same speed as cycle as no sub-sampling

      // Square - the fastest. Need rate and duty cycle. Some cheeky modulation here though
      //        if ( i % 2 == 0 ) {
      //          analogWrite(DAC0, 0xfff - c/4);
      //        } else {
      //          analogWrite(DAC0, 0x0 + c/2);
      //        }

      // Sine - with sub-sampling. TODO: Figure out sub-sample values for 'higher' frequencies
      if ( i % 4 == 0 ) {
        int d = waveData[i] / 2 + (4095 / 4 * 2);  // Adds DC offset to output to keep LED forward biased
                                                   // waveData[i] / 4 + (4095 / 4 * 3) for BLUE LEDs

        analogWrite(DAC0, d );  // waveData[i]);
      }

      delayMicroseconds(uSecDelay);
    }
  }
}

int freqs[] = { 1, 4, 8, 15 };

void sineWaves() {
  const int NUM_FREQS = sizeof(freqs) / sizeof(int);

  for (int f = 0; f < NUM_FREQS; f ++ ) {
    sineWave(freqs[f], 30);
  }  
}

void loop()
{
  sineWaves();

  // sineWave(3, 30);

  // checkPir();

  // testSpiral();

  // bigCounter();

  // nowServing();

  // scrollString( SIZE, DEVICES, "Hello there Jenny, hello there Iman!, Yo POPS :)" );

  // tempAndHumidity();

  // scrollAnimationLoop( 10 );

  // phpIs();

  // animationTest();

  // gameOfLife();

  // writeArduinoOnMatrix();
}
